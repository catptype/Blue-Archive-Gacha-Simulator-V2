{% extends 'app_web/components/base.html' %}
{% load static %}
{% block title %}Dashboard{% endblock %}

{% block body %}
<style>
    /* For Webkit-based browsers (Chrome, Safari, Edge) */
    #dashboard-content::-webkit-scrollbar {
        width: 8px; /* A thin width */
    }
    #dashboard-content::-webkit-scrollbar-track {
        background: transparent; /* Invisible track */
    }
    #dashboard-content::-webkit-scrollbar-thumb {
        background-color: rgba(107, 114, 128, 0.4); /* A semi-transparent gray handle */
        border-radius: 10px; /* Rounded corners */
        border: 2px solid transparent;
        background-clip: padding-box;
    }
    #dashboard-content::-webkit-scrollbar-thumb:hover {
        background-color: rgba(156, 163, 175, 0.6); /* Slightly more visible on hover */
    }

    /* For Firefox */
    #dashboard-content {
        scrollbar-width: thin;
        scrollbar-color: rgba(107, 114, 128, 0.4) transparent;
    }
</style>

<div class="relative min-h-screen w-full bg-black antialiased text-white pt-20">
    {% include 'app_web/components/background.html' %}

    <!-- Main Content Container with margins -->
    <div class="w-full max-w-7xl mx-auto px-4 lg:px-6 py-8">
        
        <!--
          THE NEW LAYOUT: The tabs and content panel are now combined into a single element.
          'relative' is crucial for positioning the tabs.
        -->
        <div class="relative w-full">

            <!-- =============================================================== -->
            <!-- TABS (Now on top of the content panel)                          -->
            <!-- =============================================================== -->
            <div class="absolute -top-px left-6 z-20 flex gap-1">
                <!-- 
                  Each button is now styled to look like a solid, inactive tab.
                  The active state will be applied by JavaScript.
                -->
                <button class="dashboard-tab px-6 py-2 rounded-t-lg transition-colors duration-200 border-x border-t" data-tab="dashboard">Dashboard</button>
                <button class="dashboard-tab px-6 py-2 rounded-t-lg transition-colors duration-200 border-x border-t" data-tab="history">History</button>
                <button class="dashboard-tab px-6 py-2 rounded-t-lg transition-colors duration-200 border-x border-t" data-tab="collection">Collection</button>
                <button class="dashboard-tab px-6 py-2 rounded-t-lg transition-colors duration-200 border-x border-t" data-tab="achievements">Achievements</button>
            </div>

            <!-- =============================================================== -->
            <!-- DYNAMIC CONTENT PANEL (FIXED)                                   -->
            <!-- =============================================================== -->
            <!-- 
              FIXED:
              - The 'pt-12' class has been RESTORED to create space for the tabs.
              - The main panel is now a flex container, and the content inside it will scroll.
            -->
            <div id="dashboard-content-wrapper" class="relative z-10 w-full h-[80vh] bg-slate-800/80 backdrop-blur-sm border border-slate-700 rounded-lg flex flex-col pt-12 p-6">
                
                <!-- This new inner div is now the scrollable container -->
                <div id="dashboard-content" class="flex-grow overflow-y-auto">
                    <!-- Content will be injected here by JavaScript -->
                    <div class="w-full h-full flex items-center justify-center">
                        <svg class="animate-spin h-8 w-8 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>
                    </div>
                </div>

            </div>
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const tabs = document.querySelectorAll('.dashboard-tab');
    const contentContainer = document.getElementById('dashboard-content');
    const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;
    
    // --- STATE MANAGEMENT VARIABLES ---
    let currentTab = 'dashboard';
    let isLoading = false;
    // NEW: This variable will remember the last tab clicked while loading.
    let pendingTabName = null;

    /**
     * The main function to fetch and display content for a given tab.
     * This function is now fully robust against race conditions.
     */
    async function loadTabContent(tabName) {
        // --- THE FIX: Part 1 ---
        // If a request is already running, just record the user's latest intent and exit.
        // Don't change the currentTab or update styles yet.
        if (isLoading) {
            pendingTabName = tabName;
            return;
        }

        isLoading = true;
        // The "true" current tab is only set when we actually start loading it.
        currentTab = tabName; 

        // --- 1. Update Tab Styles for the CURRENTLY loading tab ---
        tabs.forEach(tab => {
            if (tab.dataset.tab === currentTab) {
                tab.classList.add('bg-sky-800/80', 'border-slate-700', 'text-white', 'font-semibold');
                tab.classList.remove('text-slate-400', 'hover:bg-slate-700/50');
            } else {
                tab.classList.remove('bg-sky-800/80', 'border-slate-700', 'text-white', 'font-semibold');
                tab.classList.add('text-slate-400', 'hover:bg-slate-700/50');
            }
        });

        // --- 2. Show Loading State & Animate ---
        contentContainer.style.opacity = 0.5;

        // --- 3. Fetch New Content ---
        try {
            const response = await fetch(`/dashboard/${tabName}`);
            if (!response.ok) throw new Error('Failed to load content.');
            const responseText = await response.text();

            // Only inject the content if the user hasn't already clicked another tab.
            // This prevents the old content (e.g., Collection) from appearing for a split second
            // before the new content (e.g., History) starts loading.
            if (tabName === currentTab) {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = responseText;
                const htmlContent = tempDiv.querySelector('.tab-html-content');
                const scriptContent = tempDiv.querySelector('.tab-js-script');

                if (htmlContent) {
                    contentContainer.innerHTML = htmlContent.outerHTML;
                } else {
                    contentContainer.innerHTML = responseText;
                }
                if (scriptContent) {
                    eval(scriptContent.textContent);
                }
            }
        } catch (error) {
            contentContainer.innerHTML = `<p class="text-red-400 p-4">${error.message}</p>`;
        } finally {
            isLoading = false;
            contentContainer.style.opacity = 1;

            // --- THE FIX: Part 2 ---
            // After we finish, check if the user clicked another tab while we were busy.
            if (pendingTabName) {
                const nextTabToLoad = pendingTabName;
                pendingTabName = null; // Clear the pending request.

                // If the pending request is different from the tab we just finished loading,
                // immediately start loading the new one.
                if (nextTabToLoad !== currentTab) {
                    loadTabContent(nextTabToLoad);
                }
            }
        }
    }

    // --- Attach event listeners to all tabs ---
    // The listener is now simpler. It doesn't need to manage 'currentTab' itself.
    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            const tabName = tab.dataset.tab;
            if (tabName !== currentTab) {
                loadTabContent(tabName);
            }
        });
    });

    // --- Initial Load ---
    loadTabContent('dashboard');
});
</script>
{% endblock %}